/*
 * TaskGenerator.java
 * Created on Nov 6, 2007, 2:59:04 PM
 */

package tasking;

import java.util.Collection;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import simulation.Agent;
import simulation.Team;
import utility.DistanceTable;

/**
 * Interface used by Agent,Team,etc for consistency in generating tasks.
 * <br><br>
 * @author ae3263
 */
@XmlAccessorType(XmlAccessType.NONE)
public abstract class TaskGenerator {
    
    // CONSTANTS
    
    public static final int NO_TASKING=0;
    public static final int AUTO_CLOSEST=1;
    public static final int AUTO_TWO_LINE=2;
    public static final int AUTO_FARTHEST=3;
    public static final int AUTO_COM=4;
    public static final int AUTO_DIR_COM=5;
    public static final int AUTO_GRADIENT=6;
    public static final int CONTROL_CLOSEST=7;
    public static final int CONTROL_OPTIMAL=8;
    public static final String[] TASKING_STRINGS=
    {"None","Autonomous Closest","Autonomous Two Closest","Autonomous Farthest",
     "Autonomous Center-of-Mass","Autonomous Center-of-Directions",
     "Autonomous Gradient","Control Closest", "Control Optimal"};
    
    // ATTRIBUTES
    
    /** The target team for the task. */
    Team target;
    
    /** Determines the type of tasking. */
    int goalType = NO_TASKING;
    
    // CONSTRUCTORS
    
    /** Default constructor. */
    public TaskGenerator(){ target = null; }
    
    /** Constructs with given properties. */
    public TaskGenerator(Team target,int type){
        this.target = target;
        this.goalType = type;
    }

    /** Algorithm to generate tasks based on a player's information about the playing field.
     * @param pov the agents within view for the task generation
     * @param table the table of distances for the simulation's current step
     * @return list of tasks generated by this particular class
     */
    public abstract void generate(Collection<Agent> team, DistanceTable table, double priority);
    
    
    @Override
    public String toString(){
        return super.toString()+", target="+target+", type="+goalType;
    }

    public Team getTarget() {
        return target;
    }

    public void setTarget(Team target) {
        this.target = target;
    }
    
    // STATIC FACTORY METHODS    
    
    /** Return class with desired tasking
     * @param tasking the tasking code
     * @return subclass of tasking with desired algorithm */
    public static TaskGenerator getTasking(Team team, int type, int tasking){
        switch(tasking){
            case AUTO_CLOSEST:
                return new tasking.AutoClosest(team, type);
            case AUTO_TWO_LINE:     
                return new tasking.AutoTwoClosest(team, type);
            case AUTO_FARTHEST:     
                return new tasking.AutoFarthest(team, type);
            case AUTO_COM:          
                return new tasking.AutoCOM(team, type);
            case AUTO_DIR_COM:
                return new tasking.AutoDirectionCOM(team, type);
            case AUTO_GRADIENT:     
                return new tasking.AutoGradient(team, type);
            case CONTROL_CLOSEST:   
                return new tasking.ControlClosest(team, type);
            case CONTROL_OPTIMAL:
                return new tasking.ControlOptimal(team, type);
        }
        return null;
    }
}
